module: io

// IO module.

// Formatting

Printf = scheme::printf

Sprintf = scheme::format

// Interfaces

Reader = struct: Read
Writer = struct: Write
ReadWriter = struct: Read Write
ReadWriteCloser = struct: Read Write Close

// Wrapper for Scheme ports

SchemeToRWC = fun: [in, out] {
  read = fun: [n] {
    rbuf = scheme::make_bytes(n)
    num = scheme::read_bytes_avail(rbuf, in)
    if: num == 0 {
      io::EOF
    } else {
      scheme::subbytes(rbuf, 0, num)
    }
  }
  write = fun: [towr] {
    scheme::write_bytes(towr, out)
    scheme::force_output(out)
  }
  close = fun: [] {
    scheme::close_port(out)
    scheme::close_port(in)
  }
  ReadWriteCloser(read, write, close)
}

// Standard input and output

stdin_prt = scheme::current_input_port()
stdout_prt = scheme::current_output_port()

Stdio = SchemeToRWC(stdin_prt, stdout_prt)

EOF = scheme::EOF

IsEOF = fun: [x] {
  scheme::eof_objectP(x)
}

// Dump a to b

CopyIO = fun: [in, out] {
  loop: loop [] {
    bts = in.Read(4096)
    if: bts == io::EOF {
      bts
    } else {
      out.Write(bts)
      loop()
    }
  }
}

// ReadFull

ReadFull = fun: [rdr, num] {
  if: num == 0 {
    scheme::make_bytes(0)
  } else {
    thing = rdr.Read(num)
    if: IsEOF(thing,) {
      raise: "Unexpected EOF!"
    } else if: thing.Length() == num {
      thing
    } else {
      thing.Append(ReadFull(rdr, num - scheme::bytes_length(thing)))
    }
  }
}
