module: socks5
import: "~~/net.mir"
import: "~~/io.mir"

// Implements a SOCKS5 proxy.

handle = fun: [client] {
  defer: client.Close()
  
  // greeting: 0x05 num (auth methods)
  greeting = io::ReadFull(client, 2)
  when: greeting[0] != 5 {
    raise: "Does not support version other than 5"
  }
  
  // Skip the auth methods
  io::ReadFull(client, greeting[1])
  // Reply to the greeting
  repl = #b[5, 0]
  client.Write(repl)
  
  // Read the client connection request
  conreq1 = io::ReadFull(client, 4)
  when: conreq1[2] != 0 {
    raise: "Reserved field not zero"
  }
  host = ""
  port = 0
  
  // Read the destination address
  if: conreq1[3] == 1 {
    addr = io::ReadFull(client, 4)
    scheme::assign(host, io::Sprintf("~a.~a.~a.~a", addr[0], addr[1], addr[2], addr[3]))
  } else if: conreq1[3] == 3 {
    adlen = io::ReadFull(client, 1)[0]
    adbts = io::ReadFull(client, adlen)
    scheme::assign(host, scheme::bytes2string(adbts))
  } else {
    raise: "WTF!"
  }
  scheme::assign(pb, io::ReadFull(client, 2))
  scheme::assign(port, pb[0] * 256 + pb[1])
  io::Printf("Tunneling: ~a:~a\n", host, port)
  
  // Say ok (FIXME)
  client.Write(#b[5, 0, 0, 1, 0, 0, 0, 0, 0, 0])
  
  // Do le conn
  remconn = net::TCPConnect(host, port)
  yarn: {
    defer: remconn.Close()
    recover: [e] void()
    io::CopyIO(client, remconn)
  }
  recover: [e] void()
  io::CopyIO(remconn, client)
}

listener = net::TCPListen(1080)
loop: continue [n, 0] {
  client = listener.Accept()
  yarn: handle(client,)
  continue(n + 1)
}
