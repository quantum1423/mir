namespace __RUNTIME__

def _mutex() = object {
  def Impl = __SCHEME("make-mutex")()
  def Lock() = __SCHEME("mutex-lock!")(Impl)
  def Unlock() = __SCHEME("mutex-unlock!")(Impl)
}

def _cvar() = object {
  def impl = __SCHEME("make-condition-variable")()
  def Wait(mtx) = {
    __SCHEME("mutex-unlock!")(mtx.Impl, impl)
  }
  def Signal() = __SCHEME("condition-variable-signal!")(impl)
  def Broadcast() = __SCHEME("condition-variable-broadcast!")(impl)
}

def _chan() = object {
  def message = __SCHEME("#f")
  def bench = _cvar()
  def lock = _mutex()
  def wlock = _mutex()
  def rlock = _mutex()
  def message_in = __SCHEME("#f")
  def want = __SCHEME("#f")
  
  def Send(msg) = {
    lock.Lock()
    // Wait until want
    while want == __SCHEME("#f") bench.Wait(lock)
    // Put message in
    message = msg
    message_in = __SCHEME("#t")
    bench.Signal()
    // Wait until message gotten
    while message_in bench.Wait(lock)
    lock.Unlock()
  }
  
  def Recv() = {
    lock.Lock()
    want = __SCHEME("#t")
    bench.Signal()
    // Wait until message available
    while message_in == __SCHEME("#f") bench.Wait(lock)
    // obtain message
    def toret = message
    message_in = false
    want = __SCHEME("#f")
    bench.Signal()
    lock.Unlock()
    toret
  }
}

def _semaphore(counter) = object {
  def bench = _cvar()
  def lock = _mutex()
  
  def Post() = {
    lock.Lock()
    counter = counter + 1
    bench.Broadcast()
    lock.Unlock()
  }
  
  def Wait() = {
    lock.Lock()
    while counter == 0 bench.Wait(lock)
    counter = counter - 1
    lock.Unlock()
  }
}

// TODO: Fix this. Performance is O(n), which is really really bad
def _achan(limit) = object {
  def sem1 = _semaphore(limit)
  def sem2 = _semaphore(0)
  def xaxa = __SCHEME("'()")
  def lock = _mutex()
  
  def Send(msg) = {
    sem1.Wait()
    lock.Lock()
    xaxa = __SCHEME("cons")(msg, xaxa)
    lock.Unlock()
    sem2.Post()
  }
  
  def Recv() = {
    sem2.Wait()
    lock.Lock()
    def toret = __SCHEME("car")(__SCHEME("reverse")(xaxa))
    xaxa = __SCHEME("(reverse (cdr (reverse %%xaxa)))")
    lock.Unlock()
    sem1.Post()
    toret
  }
}
  

def _future(thunk) = {
  def lock = _mutex()
  def opened = 0
  def thing = 0
  fun() {
    lock.Lock()
    if opened != 0 {
      lock.Unlock()
      thing
    } else {
      def hoho = thunk()
      opened = 1
      thing = hoho
      lock.Unlock()
      hoho
    }
  }
}

def __recv() = {
  def raa = __SCHEME("thread-receive")()
  def msg = __SCHEME("car")(raa)
  def rch = __SCHEME("cdr")(raa)
  __SCHEME("thread-specific-set!")(__SCHEME("current-thread")(), rch)
  msg
}

def __reply(rep) = {
  __SCHEME("(thread-specific (current-thread))").Send(rep)
  __SCHEME("thread-specific-set!")(__SCHEME("current-thread")(), 0)
}

def __send(yrn, msg) = {
  def repchan = _chan()
  __SCHEME("thread-send")(yrn, __SCHEME("cons")(msg, repchan))
  repchan.Recv()
}
  
