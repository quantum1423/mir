namespace __RUNTIME__

def _mutex() = object {
  def Impl = __SCHEME("make-mutex")()
  def Lock() = __SCHEME("mutex-lock!")(Impl)
  def Unlock() = __SCHEME("mutex-unlock!")(Impl)
}

def _cvar() = object {
  def impl = __SCHEME("make-condition-variable")()
  def Wait(mtx) = {
    __SCHEME("mutex-unlock!")(mtx.Impl, impl)
  }
  def Signal() = __SCHEME("condition-variable-signal!")(impl)
  def Broadcast() = __SCHEME("condition-variable-broadcast!")(impl)
}

def _chan() = object {
  def message = __SCHEME("#f")
  def bench = _cvar()
  def lock = _mutex()
  def status = 0 // 0 means nobody on bench, 1 means reader waiting, 2 means writer waiting
  
  def Send(msg) = {
    lock.Lock()
    while status != 1 bench.Wait(lock) // wait until somebody wants a message
    message = msg
    status = 2
    bench.Signal()
    while status != 0 bench.Wait(lock) // wait until nobody in
    lock.Unlock()
  }
  
  def Recv() = {
    lock.Lock()
    status = 1
    bench.Signal()
    while status != 2 bench.Wait(lock)
    def toret = message
    status = 0
    toret
  }
}

def _semaphore(counter) = object {
  def bench = _cvar()
  def lock = _mutex()
  
  def Post() = {
    lock.Lock()
    counter = counter + 1
    bench.Broadcast()
    lock.Unlock()
  }
  
  def Wait() = {
    lock.Lock()
    while counter == 0 bench.Wait(lock)
    counter = counter - 1
    lock.Unlock()
  }
}

// TODO: Fix this. Performance is O(n), which is really really bad
def _achan(limit) = object {
  def sem1 = _semaphore(limit)
  def sem2 = _semaphore(0)
  def xaxa = __SCHEME("'()")
  def lock = _mutex()
  
  def Send(msg) = {
    sem1.Wait()
    lock.Lock()
    xaxa = __SCHEME("cons")(msg, xaxa)
    lock.Unlock()
    sem2.Post()
  }
  
  def Recv() = {
    sem2.Wait()
    lock.Lock()
    def toret = __SCHEME("car")(__SCHEME("reverse")(xaxa))
    xaxa = __SCHEME("(reverse (cdr (reverse %%xaxa)))")
    lock.Unlock()
    sem1.Post()
    toret
  }
}
  

def _future(thunk) = {
  def lock = _mutex()
  def opened = 0
  def thing = 0
  fun() {
    lock.Lock()
    if opened != 0 {
      lock.Unlock()
      thing
    } else {
      def hoho = thunk()
      opened = 1
      thing = hoho
      lock.Unlock()
      hoho
    }
  }
}

def __recv() = {
  def raa = __SCHEME("thread-receive")()
  def msg = __SCHEME("car")(raa)
  def rch = __SCHEME("cdr")(raa)
  __SCHEME("thread-specific-set!")(__SCHEME("current-thread")(), rch)
  msg
}

def __reply(rep) = {
  __SCHEME("(thread-specific (current-thread))").Send(rep)
  __SCHEME("thread-specific-set!")(__SCHEME("current-thread")(), 0)
}

def __send(yrn, msg) = {
  def repchan = _achan(1)
  __SCHEME("thread-send")(yrn, __SCHEME("cons")(msg, repchan))
  _future(repchan.Recv)
}
  
